###基本概念
散列表又称杂凑表，是一种十分实用的查找技术，具有极高的查找效率。
其基本思想是根据**关键码值（查找码）**与表项**存储地址**的映射关系，进行高效、精确地查找。
查找效率与散列函数的计算复杂度、冲突解决方案的使用有直接的关系。    
 
###冲突
当两个不同的记录被散列函数映射到同一个地址时，称为冲突，冲突会降低效率。
为了尽可能避免冲突，应选择列好的**散列函数**，使用同等概念取值域。 
当关键码比较多时，很可能出现**散列函数值相同**的情况，这就是冲突。
通常也称为冲突的两个关键是该散列函数的同义词，**负载因子越大发生碰撞的可能性也越大**。
通常解决冲突的方法是设法在散列表中找一个空位，而常见的方法有两种：**开放定址法和拉链法**。    
哈希表插入的时间复杂度与冲突次数有关，O(冲突次数/n)
     
###散列函数构造方法

* 直接定址法：hash ( key ) = a * key + b      { a, b为常数 }

* 数字分析法
* 平方取中法
* 折叠法
* 随机数法
* 除留余数法
* 乘余取整法

###拉链法
基本思想：将所有哈希地址为i 的元素构成一个称为同义词链的链表，并将链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在
同义词链中进行。 

###线性探测再散列
```
Hi = (Hi-1 + 1) % m
```
或
```
Hi = (H0 + i) % m,i = 1,2,……，m-1
```
例1：    
假定有k个关键字互为同义词，若用线性探测法把这k个关键字存入散列表中，至少要进行**k(k+1)/2**次探测    
原因：第1个直接存入（探测1次），第2个冲突1次（探测2次），…，第k个冲突（k-1）次（探测k次），故一共**K(k+1)/2**     
例2：    
已知一个线性表(38,25,74,63,52,48)，采用的散列函数为H(Key)=Key mod 7，将元素散列到表长为7的哈希表中存储。
若采用线性探测的开放定址法解决冲突，则在该散列表上进行等概率成功查找的平均查找长度为_______.      
解：   

| 关键字              | 38 | 25 | 74 | 63 | 52 | 48 |
|:-----------:        |:--:|:--:|:--:|:--:|:--:|:--:|
| 散列地址（关键字%7）| 3  | 4  | 4  | 0  | 3  | 6  |

| 关键字              | 63 | 48 |    | 38 | 25 | 74 | 52 |
|:-----------:        |:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|成功比较次数         | 1  | 3  |    | 1  | 1  | 2  | 4  | 

38%7 = 3--->1次   
25%7 = 4--->1次   
74%7 = 4--->75%7 = 5--->2次   
63%7 = 0--->1次   
52%7 = 3--->53%7 = 4--->54%7 = 5--->55%7 = 6--->4次   
48%7 = 6--->49%7 = 0--->50%7 = 1--->3次   

所以：平均用了(1+3+1+1+2+4)/6=2.0。

###二次探测再散列
```
Hi = (H0 + i^2) % m
Hi = (H0 - i^2) % m
```
1^2,-1^2,2^2,-2^2,……     
m为表的大小，它应该是一个值为**4k+3**的质数。

###查找性能比较

* Hash操作能根据散列值直接定位数据的存储地址，设计良好的hash表能在常数级时间下找到需要的数据，
但是更适合于内存中的查找。

* B+树是一种是一种树状的数据结构，适合做索引，对磁盘数据来说，索引查找是比较高效的

* STL_Map的内部实现是一颗红黑树，但是只是一颗在内存中建立二叉树树，不能用于磁盘操作，
而其内存查找性能也比不上Hash查找