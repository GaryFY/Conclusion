###IO库函数

* C标准I/O函数：
* Unbuffered I/O函数：每次读写都要进内核，调一个系统调用比调一个用户空间的函数要慢很多，所以再用户空间开辟I/O缓冲区是必要的。
网络编程通常直接调用Unbuffered I/O函数

###文件描述符
文件描述符表的索引
* 当调用open 打开一个文件或创建一个新文件时,内核分配一个文件描述符并返回给用户程序,该文件描述符表项中的指针指向新打开的文件。
* 当读写文件时,用户程序把文件描述符传给read 或write ,内核根据文件描述符找到相应的表项,再通过表项中的指针找到相应的文件。
**减少引用次数，当引用次数为0时，才关闭文件**    
file结构体：
* dentry:directory entry(路径)
* dentry cache:为了减少读盘次数，内核缓存了目录的树状结构
* 每个dentry结构体都有一个指针只想inode结构体：inode 结构体保存着从磁盘inode读上来的信息。
每个inode 结构体都有一个指向inode_operations结构体的指针,后者也是一组函数指针指向一些完成文件目录操作的内核函数（影 响文件和目录布局的函数）。 
* inode结构体记录了很多关于文件的信息，比如文件长度，文件所在的设备，文件的物理位置，创建、修改和更新时间等等，
特别的，它不包含文件名！目录下的所有文件名和目录名都存储在目录的数据块中，即如下图的目录块。

###C标准库IO缓冲区和内核缓冲区的区别
####C标准库的I/O缓冲区

C标准库为每个打开的文件分配一个I/O缓冲区以加速读写操作,通过文件的FILE 结构体可以找到这个缓冲区,
用户调用读写函数大多数时候都在I/O缓冲区中读写,只有少数时候需要把读写请求传给内核    
例：以fgetc / fputc 为例,当用户程序第一次调用fgetc 读一个字节时,fgetc 函数可能通过系统调用 进入内核读1K字节到I/O缓冲区中,
然后返回I/O缓冲区中的第一个字节给用户,把读写位置指 向I/O缓冲区中的第二个字符,以后用户再调fgetc ,就直接从I/O缓冲区中读取,
而不需要进内核 了,当用户把这1K字节都读完之后,再次调用fgetc 时,fgetc 函数会再次进入内核读1K字节 到I/O缓冲区中。    
有时候用户程序希望把I/O缓冲区中的数据立刻 传给内核,让内核写回设备或磁盘,这称为Flush操作,对应的库函数是fflush,fclose函数在关闭文件 之前也会做Flush操作。     
C标准库的I/O缓冲区有三种类型:**全缓冲、行缓冲和无缓冲**。
* 全缓冲 ：如果缓冲区写满了就写回内核。常规文件通常是全缓冲的。 
* 行缓冲 ：如果用户程序写的数据中有换行符就把这一行写回内核,或者如果缓冲区写满了就写回内核。
**标准输入和标准输出对应终端设备时通常是行缓冲的**。
* 无缓冲 ：用户程序每次调库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的,这样用户程序产生的错误信息可以尽快输出到设备。     

除了**写满缓冲区、写入换行符**之外,行缓冲还有两种情况会自动做Flush操作。如果: 
* 用户程序调用库函数从无缓冲的文件中读取 
* 或者从行缓冲的文件中读取,并且这次读操作会引发系统调用从内核读取数据

####用户程序的缓冲区
由调用者分配并传给函数读或写的一段内存通 常称为缓冲区(Buffer),缓冲区写越界的错误称为缓冲区溢出(Buffer Overflow)    

####内核缓冲区
内核空间是进程共享的，而进程的用户空间是完全独立的   
FIFO/UNIX Domain Socket

###重入
重入：有可能再第一次调用还没返回时就再次进入该函数，这称为重入   
不可重入函数的原因在于：
1> 已知它们使用静态数据结构    
2> 它们调用malloc和free.   
因为malloc通常会为所分配的存储区维护一个链接表，而插入执行信号处理函数的时候，进程可能正在修改此链接表。
3> 它们是标准IO函数.   
因为标准IO库的很多实现都使用了全局数据结构    

###多线程冲突
对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是**引入锁**，获得锁的线程可以完成“读-修改-写”操作，
然后释放锁给其他线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，
要么都执行，要么都不执行，不会执行到中间被打断，也不会再其他处理器上并行做这个操作。   
volatile并不能保证操作的原子性，再读取、写入变量的过程中仍然可能被其他线程打断导致意外结果发生。

###read/write函数
```
ssize_t read(int fd, void *buf, size_t count);
```
返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0  
**参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移**      
**读写位置记在内核中的**
* 读常规文件时，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有30个字节而请求读100个字节，则read返回30，下次read将返回0。
* 从终端设备读，通常以行为单位，读到换行符就返回了。
* 从网络读，根据不同的传输层协议和内核缓存机制，返回值可能小于请求的字节数。
```
ssize_t write(int fd, const void *buf, size_t count);
```
返回值：成功返回写入的字节数，出错返回-1并设置errno    

注意：   
* 读常规文件是不会阻塞的，不管读多少字节，read一定会在有限的时间内返回。
* 从终端设备或网络读则不一定，如果从终端输入的数据**没有换行符**，调用read读终端设备就会阻塞，
如果网络上**没有接收到数据包**，调用read从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。
同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。

###（非）阻塞I/O
阻塞：当进程调用一个阻塞的系统函数时，该进程被置于睡眠（Sleep）状态，这时内核调度其它进程运行，
直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用sleep指定的睡眠时间到了）它才有可能继续运行  
```
while(1) 
{ 
非阻塞read(设备1); 
if(设备1有数据到达) 
处理数据; 
非阻塞read(设备2); 
if(设备2有数据到达) 
处理数据; 
..............................
}
``` 
```
while(1) 
{ 
非阻塞read(设备1); 
if(设备1有数据到达) 
处理数据; 
非阻塞read(设备2); 
if(设备2有数据到达) 
处理数据; 
..............................
sleep(n);
}
```

非阻塞：如果所有设备都一直没有数据到达，调用者需要反复查询做无用功   


* sync.是强制将所有页面缓冲区都更新到磁盘上。
* fsync.是强制将某个fd涉及到的页面缓存更新到磁盘上(包括文件属性等信息).
* fdatasync.是强制将某个fd涉及到的数据页面缓存更新到磁盘上。
