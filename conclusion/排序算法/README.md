七大排序总结篇
====

####冒泡排序

* 冒泡排序主要思路是：（保证最大元素就位）    
通过交换使相邻的两个数变成小数在前大数在后，这样每次遍历后，最大的数就“沉”到最后面了。重复N次即可以使数组有序。

* 冒泡排序改进1：在某次遍历中如果没有数据交换，说明整个数组已经有序。因此通过设置标志位来记录此次遍历有
无数据交换就可以判断是否要继续循环。

* 冒泡排序改进2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。
因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。

####直接插入排序

直接插入排序主要思路是：   
每次将一个待排序的数据，插入到前面已经排好序的序列之中，直到全部数据插入完成。

####直接选择排序

直接选择排序主要思路是：    
数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，
直到整个数组变有序区。

####希尔排序

希尔排序主要思路是：     
先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，
然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。
由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称希尔排序为“跳着插”

####归并排序

归并排序主要思路是：    
当一个数组左边有序，右边也有序，那合并这两个有序数组就完成了排序。如何让左右两边有序了？用递归！
这样递归下去，合并上来就是归并排序。

####快速排序

快速选择排序主要思路是：    
“挖坑填数+分治法”，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j--由后向前找比基准数小的数，
找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。
重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。
因此将数组分成二部分再分别重复上述步骤就完成了排序。

####堆排序

* 堆的插入     
就是每次插入都是将新数据放在数组最后，而从这个新数据的父结点到根结点必定是一个有序的数列，
因此只要将这个新数据插入到这个有序数列中即可。

* 堆的删除   
就是—堆的删除就是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。
调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，
反之将父结点和它交换后再考虑后面的结点。相当于从根结点开始将一个数据在有序数列中进行“下沉”。

####总结

[CSDN](http://img.my.csdn.net/uploads/201209/09/1347195747_3017.PNG)

时间复杂度
----

| 排序法 | 平均时间 | 最好情形   |最差情形   | 稳定度 | 额外空间 |   备注  | 
| :----: | :----:   | :----:     | :----:    | :----: |:----:    |  :----: |
| 冒泡   | O(n^2)   | O(n)       |O(n^2)     |  稳定  |O(1)      |n小时较好|
| 交换   | O(n^2)   |            |O(n^2)     | 不稳定 |O(1)      |n小时较好|
| 选择   | O(n^2)   | O(n^2)     |O(n^2)     | 不稳定 |O(1)      |n小时较好|
| 插入   | O(n^2)   | O(n)       |O(n^2)     |  稳定  |O(1)      |大部分已排序十时较好|
| 基数   | O(logR B)| O(logR B)  |O(logR B)  |  稳定  |O(n)      |B是真数，R是基数|
| shell  | O(nlogn) | O(n)       |O(n^s)1<s<2| 不稳定 |O(1)      |s是所选分组|
| 快速   | O(nlogn) | O(nlogn)   |O(n^2)     | 不稳定 |  O(nlogn)|n大时较好|
| 归并   | O(nlogn) | O(nlogn)   |O(nlogn)   |  稳定  |O(1)      |n大时较好|
| 堆     | O(nlogn) | O(nlogn)   |O(nlogn)   | 不稳定 |O(1)      |n大时较好|

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)    

####比较和交换次数

* 直接插入排序：最好：比较n-1次，最坏：2+3+...+n=(n+2)(n-1)/2次  ,移动：i+1(i=1,2...n)=(n+4)(n-1)/2次
* 选择排序：比较次数：n(n-1)/2，交换次数最好的时候为0，最差的时候为n-1
* 冒泡排序：最好：n-1次比较（移动次数为0），最坏：n(n-1)/2次比较（等数量级的移动）


[算法比较](http://uploadfiles.nowcoder.com/images/20150917/266279_1442481223258_BB3663E2B94AB7FD90C31D24E4C6E7EB)
[复杂度](https://uploadfiles.nowcoder.com/images/20160526/285375_1464276927504_9D9A7BC3D3161F7CA5658A9A9E672686)