C++
----

###变量与内存相关    

一、int a = 0和int a区别：    
     
前者开辟内存，存放0；后者没有开辟内存     
		
二、局部变量和全局变量的内存    
   
局部变量->栈   
全局变量->全局/静态存储区    
		
三、变量内存形式        

栈、堆（new）、自由存储区（malloc）、全局/静态存储区、常量存储区    
		
四、进程空间布局？		
   
程序代码区（.text）、文字常量区（.rodata）、全局区/静态区（static）、堆区（heap）、栈区（stack）
		
五、static（全局和局部）       	

static变量：
        
* static全局：在全局数据区内分配内存；如果没有初始化，其默认值为0，只初始化一次；该变量在本**文件内**从定义开始到文件结束可见   
* static局部：该变量在全局数据区分配内存；如果不显示初始化，那么将被隐式初始化为0； 它始终驻留在全局数据区，直到程序运行结束；
其作用域为**局部作用域，当定义它的函数或语句块结束时，其作用域随之结束**。    
静态数据成员（类中static关键字）：   
* 内存分配：在程序的全局数据区分配（只分配一次内存）
* 初始化和定义：静态数据成员定义时要分配空间，所以不能在类声明中定义
静态成员函数：
* 出现在类体外的函数定义不能指定关键字static。
* 静态成员函数不能访问非静态成员函数和非静态数据成员。
* 静态成员函数和静态数据成员都没有this指针。
		
六、define宏定义和const常变量的区别：   
      
* define：系统不为它分配内存；预处理时进行替换，编译不进行数据类型检验；注意“边缘效应”     
* const：系统为它分配内存；编译时进行严格的类型检验     
		
七、const int* p与int const* p区别:   
 
const int* p:*p是常量，const int *与int const*是一样的，指针指向的**内容是一个常量**，不能改变，指针**指向的地址可以改变。**
而int *const与以上两者相反，**指向的内容可以改变，指向的地址不能改变**。   
			

###重点与难点

一、构造函数与析构函数的作用  
  
构造函数主要用来在创建对象时完成对对象属性的一些初始化等操作, 当创建对象时, 对象会自动调用它的构造函数。
一般来说, 构造函数有以下三个方面的作用:
* 给创建的对象建立一个标识符;
* 为对象数据成员开辟内存空间;
* 完成对象数据成员的初始化。
析构函数是在对象被撤销时被自动调用, 用于对成员撤销时的一些清理工作, 例如在前面提到的手动释放使用 new 或 malloc 进行申请的内存空间。析构函数具有以下特点:
* 析构函数函数名与类名相同, 紧贴在名称前面用波浪号 ~ 与构造函数进行区分, 例如: ~Point();
* 构造函数没有返回类型, 也不能指定参数, 因此析构函数只能有一个, 不能被重载;
* 当对象被撤销时析构函数被自动调用, 与构造函数不同的是, 析构函数可以被显式的调用, 以释放对象中动态申请的内存。   
		
		
二、sizeof 构造函数和析构函数    

不为其分配内存   
		
三、重载、覆盖和隐藏   

重载：相同的范围；函数名相同；参数不同；virtual关键字可有有无    
覆盖：不同的范围；函数名相同；参数相同；virtual必须要有；返回值与基类的函数相同    
隐藏：
* 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。
* 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。  
		
四、多态概念及内部实现（虚函数）  

多态性是“一个接口，多种方法”   
多态性分为两类: 静态多态性和动态多态性。      
**以前学过的函数重载和运算符重载实现的多态性属于静态多态性，动态多态性是通过虚函数(virtual function)实现的。**
* 静态多态性是指在程序编译时系统就能决定调用的是哪个函数，因此静态多态性又称编译时的多态性。
* 动态多态性是在程序运行过程中才动态地确定操作所针对的对象。
原理：类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
对于虚函数调用来说，每一个对象内部都有一个虚表指针，该虚表指针被初始化为本类的虚表。
在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用。      
单继承：所有的虚函数都包含在虚函数表中    
多继承：有多个虚函数表    
		
五、深拷贝，浅拷贝？什么时候用到拷贝函数？     

拷贝函数：**传值会调用拷贝构造函数；引用不调用拷贝构造函数**
a.一个对象以值传递的方式传入函数体； b.一个对象以值传递的方式从函数返回； c.一个对象需要通过另外一个对象进行初始化     
深拷贝和浅拷贝主要区别：复制指针时是否重新创建内存空间   
深拷贝：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配
浅拷贝：**没有创建内存只赋值地址**；没有重新分配资源；浅拷贝在类里面有指针成员的情况下只会复制指针的地址，会导致两个成员指针指向同一块内存，
这样要是分别delete释放时就会出现问题，因此需要用深拷贝
		
六、子类、父类中的名称遮掩，如何避免？   

子类public继承父类的函数，子类的方法名会遮掩父类的相同名的方法，即使父类和子类内的函数有不同的参数类型也适用而且不论函数是virtual或non-virtual。
子类要想访问父类的方法，使用**using 父类名::函数名**。 或转交函数。    
		
七、C++如何避免内存泄漏？    

* 如果class中仅仅是一些普通资源，那么位逐次拷贝（浅拷贝）是完全够用的；
* 然而，当在该class中存在了一块动态分配的内存，并且在之后执行了浅拷贝后，将会有一个按位拷贝的对象和原来class中的某个成员指向同一块堆空间，
当执行它们的析构函数后，该内存将被释放两次，这是未定义的行为。   
因此，在必要的时候需要使用深拷贝，来避免内存泄露。**位拷贝拷贝的是地址，而值拷贝则拷贝的是内容**。
		
八、new/delete和malloc/free的区别和联系      

区别：   

* malloc和free是C语言标准函数库中的两个函数，new/delete是C++语言中两个运算符。
* new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，
而malloc则只分配内存，不会进行初始化类成员的工作，同样free 也不会调用析构函数。
* malloc得到的指针无类型，new出来的指针是带有类型信息的。
* 对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时 要自动执行构造函数，对象在消亡之前要自动执行析构函数。
由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
* 如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete 必须配对使用，malloc/free也一样
联系：malloc/free和new/delete都是用来申请动态内存的。   
		
九、 堆栈的区别     

* 管理方式：对于栈来讲，是由编译器自动管理；对于堆来说，释放工作由程序员控制
* 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量碎片，使程序效率降低；
对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。
* 对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；
对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
* 分配方式：堆都是动态分配的，没有静态分配的堆；栈有2 种分配方式：静态分配和动态分配。
* 分配效率：栈是机器系统提供的数据结构，计算机会在底层分配专门的寄存器存放栈的地址，
压栈出栈都有专门的指令执行，这就决定了栈的效率比较高；堆则是C/C++函数库提供的。堆的效率比栈要低得多。
		
十、struct和class的区别     
  
对于成员访问权限以及继承方式，class中默认的是private的，而struct中则是public的。
class还可以用于表示模板类型，struct则不行。
		
十一、指针和引用的区别？    
   
* 指针是一个变量，存储内容是一个地址，指向内存的一个存储单元。
而引用是原变量的一个别名，实质上和原变量是一个东西，是某块内存的别名。
* **指针的值可以为空**，且非const指针可以被重新赋值以指向另一个不同的对象。
而**引用的值不能为空，并且引用在定义的时候必须初始化，一旦初始化，就和原变量“绑定”，不能更改这个绑定关系**。
* 对指针执行sizeof()操作得到的是**指针本身的大小**（32位系统为4,64位系统为8）。
而对引用执行sizeof()操作得到的是所绑定的**对象的所占内存大小**
* 指针的自增(++)运算表示对**地址的自增**，自增大小要看所指向单元的类型。而引用的自增(++)运算表示对**值的自增**。
* 函数参数进行传递时的区别：
指针所以函数传输作为传递时，函数内部的指针形参是指针实参的一个副本，**改变指针形参并不能改变指针实参的值，
通过解引用*运算符**来更改指针所指向的内存单元里的数据。    
引用在作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，
因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。  
		
十二、处理new分配内存失败情况？    
 
* 抛出bad_alloc异常来报告分配失败
* 返回空指针，而不会抛出异常
		
十三、C++是不是类型安全的？   
 
不是。两个不同类型的指针之间可以强制转换（用reinterpret_cast)。
		
十四、当一个类A 中没有声命任何成员变量与成员函数这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。     

通常是1，用作占位的。为了确保不同对象有不同的地址。
		
十五、为什么内联函数，构造函数，静态成员函数不能为virtual函数？    

* 内联函数：内联函数是在编译时期展开,而虚函数的特性是**运行时才动态联编**,所以两者矛盾,不能定义内联函数为虚函数
* 构造函数：构造函数用来创建一个新的对象,而虚函数的运行是**建立在对象的基础上**,在构造函数执行时,**对象尚未形成**,所以不能将构造函数定义为虚函数
* 静态成员函数：静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别    
		
十六、C++函数中那些不可以被声明为虚函数的函数？为什么C++不支持友元函数为虚函数？    
  
* 常见的不能声明为虚函数的有：普通函数（非成员函数）；静态成员函数；内联成员函数；构造函数；友元函数。
* 因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。
		
十七、构造函数和析构函数为什么没有返回值？      

在程序中创建和消除一个对象的行为非常特殊，就像出生和死亡，而且总是由编译器来调用这些函数以确保它们被执行。
如果它们有返回值，要么编译器必须知道如何处理返回值，要么就只能由客户程序员自己来显式的调用构造函数与析构函数，
这样一来，安全性就被人破坏了。
	 
十八、函数模板与类模板的区别?     
 
函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。
**即函数模板允许隐式调用和显式调用，而类模板只能显示调用**。
		
十九、基类的析构函数不是虚函数，会带来什么问题？    

如果基类的为虚的话，那么在释放派生类对象的时候，会首先调用派生类的析构函数，然后再调用基类的析构函数；
如果基类析构函数不为虚的话，在释放派生类对象的时候就不会调用派生类的析构函数，有可能造成内存泄露。    
		
二十、构造函数可以调用虚函数吗？语法上通过吗？语义上可以通过吗？     
  
调用当然是没有问题的，但多态这个功能被屏蔽了。  
		
二十一、析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？     

* C++中析构函数的执行不应该抛出异常
* 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，
则这些动作不会执行，会造成诸如资源泄漏的问题。
通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，
则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。   
* 解决办法：那就是把异常完全封装在析构函数内部，决不让异常抛出函数之外。如使用
```
Try
 {  }
Catch
{/这里可以什么都不做，只是保证catch块的程序抛出的异常不会被扔出析构函数之外。} 
```
		
二十二、c++中类型转换机制？各适用什么环境？dynamic_cast转换失败时，会出现什么情况？    

* static_cast   
最常用的类型转换符，在正常状况下的类型转换，如把int转换为float，如：int i；floatf； f=（float）i；或者f=static_cast<float>(i);
* const_cast    
用于取出const属性，把const类型的指针变为非const类型的指针，如：const int *fun(int x,int y){}int *ptr=const_cast<int*>(fun(2.3))
* dynamic_cast（在继承体系中使用）    
该操作符用于运行时检查该转换是否类型安全，但只在多态类型时合法，即该类至少具有一个虚拟方法。dynamic_cast主要用于类层次间的上行转换和下行转换
* .reinterpret_cast（最常用途是转换函数指针类型）    
interpret是解释的意思，reinterpret即为重新解释，此标识符的意思即为数据的二进制形式重新解释，但是不改变其值。
如：int i; char *ptr="hello freind!";i=reinterpret_cast<int>(ptr);这个转换方式很少使用。     
dynamic_cast转换失败时**对指针，返回NULL;对引用，抛出bad_cast异常**    
		
二十三、虚函数与纯虚函数区别？    
  
纯虚函数最显著的特征是：**它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。**   

* 虚函数和纯虚函数可以定义在同一个类(class)中，含有纯虚函数的类被称为抽象类(abstract class)，而只含有虚函数的类(class)不能被称为抽象类(abstract class)。
* 虚函数可以被直接使用，也可以被子类(sub class)重载以后以多态的形式调用，
而纯虚函数必须在子类(sub class)中实现该函数才可以使用，因为纯虚函数在基类(base class)只有声明而没有定义。
* 虚函数和纯虚函数都可以在子类(sub class)中被重载，以多态的形式被调用 
		
二十四、C++ static、const和static const 以及它们的初始化?       

* static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，
* const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cosnt。
* static const 的整型(bool，char，int，long)可以在类声明中初始化    
		
二十五、私有继承作用？is-a,has-a区别？     

私有继承是一种实现继承，有“with a”的语义。子类利用父类中某些代码实现子类的某些功能。
is-a是继承关系，has-a是组合关系。
		
二十六、在构造函数和析构函数中抛出异常会发生什么？什么是栈展开？      

* 构造函数中可以抛出异常，构造抛异常之前必须把已经申请的资源释放掉。这样，就算你的对象是new出来的，也不会造成内存泄漏;
因为析构函数不会被调用，所以抛出异常后，你没机会释放资源。在构造函数中抛出异常导致析构这个对象。   
* C++中通知对象构造失败的唯一方法那就是在构造函数中抛出异常；
* 构造函数中抛出异常将导致对象的析构函数不被执行；
* 当对象发生部分构造时，已经构造完毕的子对象将会逆序地被析构；   
栈展开：抛出异常时，将暂停当前函数的执行，开始查找匹配的catch子句。首先检查throw本身是否在try块内部，
如果是，检查与该try相关的catch子句，看是否可以处理该异常。如果不能处理，就退出当前函数，
并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的catch。
		
二十七、++iterator 和iterator++效率问题？      
  
两种方式iterator遍历的次数是相同的，但在STL中效率不同，**前++返回引用，后++返回一个临时对象**，
因为iterator是类模板，使用 it++这种形式要返回一个无用的临时对象，而it++是函数重载，所以编译器无法对其进行优化，所以每遍历一个元素，你就创建并销毁了一个无用的临时对象。
除了特殊需要和对内置类型外，使用**++it来进行元素遍历**的
		
二十八、string的内存怎么实现的，长度的动态变化怎么处理，为什么两倍扩展。stringa; string b = a;这时会不会有内存拷贝相关的东西？     

* String对象可能是1~7倍char*大小，当插入string的长度大于其Capacity会重新分配一个2倍长度的内存，
将现在的内容拷贝过去然后将新的内容加入到尾部，并将老的空间释放掉。
* 不会有拷贝相关的东西，b和a指向同一地址的字符串，引用计数加1.
		
二十九、动态链接和静态链接比较？   

静态库：代码的装载速度快，执行速度也比较快，因为编译时它只会把你需要的那部分链接进去，应用程序相对比较大。
但是如果多个应用程序使用的话，会被装载多次，浪费内存。动态链接可以动态的安装和卸载，更加灵活。  
		
三十、抛出exception、传递对象到函数、和调用虚函数之间的差异？    

* exception对象总是会被复制，如果以by value方式捕捉，它会被复制两次。传递给函数的对象则不一定得复制。
* 被抛出的exception只允许继承架构中的类型转换和有型指针与void* 转化，所以一个对const void* 指针而设计的catch子句，可以捕捉任何指针类型的exception。
* exception处理机制采用最先吻合策略，第一个匹配成功者便执行，而虚函数则采用最佳吻合策略。
* 函数调用控制权最终会回到调用端，而抛出一个exception控制权不会回再回到抛出端。
		
####STL
一、为何map和set的插入删除效率比用其他序列容器高？    

**对于关联容器来说，不需要做内存拷贝和内存移动**     
map和set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。
因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。
删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点就OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。
		
二、STL的vector：增减元素对迭代器的影响？    

* 对于连续内存容器，如vector、deque等，增减元素均会使得当前之后的所有迭代器失效。  
删除元素：erase()总是指向被删除元素的下一个元素的有效迭代器
* 对于非连续内存容器，如set、map等。增减元素只会使得当前迭代器无效
删除元素：erase()返回的迭代器将是无效的迭代器  
		
三、STL中排序算法的实现是什么？    

STL中的sort()，在数据量大时，采用quicksort，分段递归排序；
一旦分段后的数量小于某个门限值，改用Insertion sort，避免quicksort深度递归带来的过大的额外负担；
如果递归层次过深，还会改用heapsort。 
		
四、为何map和set不能像vector一样有个reserve函数来预分配数据？    

引起它的原因在于在map和set内部存储的已经不是元素本身了，而是包含元素的节点。
记住一点，在**map和set内部的分配器已经发生了变化**，reserve方法你就不要奢望了。  
		
五、hash_map和map的区别在哪里？什么时候需要用hash_map，什么时候需要用map?     

* 构造函数。hash_map需要hash函数，等于函数；map只需要比较函数(小于函数).
* 存储结构。hash_map采用hash表存储，map一般采用 红黑树(RB Tree) 实现。因此其memory数据结构是不一样的。
hash_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。
**在元素达到一定数量级时，考虑考虑hash_map**；
**若你对内存使用特别严格，希望程序尽可能少消耗内存，不考虑hash_map**；
**hash_map的构造速度较慢**    
		
六、为什么auto_ptr不能用在容器中？    

STL容器在分配内存的时候，必须要能够拷贝构造容器的元素。而且拷贝构造的时候，不能修改原来元素的值。
而auto_ptr在拷贝构造的时候，一定会修改元素的值。所以STL元素不能使用auto_ptr。因为两个auto_ptr不能管理同一块内存。
		

###Linux与网络

一、TCP三次握手以及为什么三次握手   
 
三次握手的目的：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
client发出的第一个链接请求报文段并没有丢失，而是在某个网络结点长时间地滞留了，以致延误到练级而是放以后的某个时间
才到达server，server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的链接请求，于是向client发出确认报文，
同意建立连接，如果不采用三次握手，一旦server发出确认，新的连接就建立了。这样server就一直等待client发来数据。server
的很多资源就白白浪费掉了。     
     
二、为什么四次断开    

因为TCP有个半关闭状态，假设A，B要释放连接，那么A发送一个释放连接报文给B，B收到后发送确认，这个时候A不发数据，
但是B如果发数据A还是要接受，这叫半关闭。然后B还要发给A连接释放报文，然后A发确认，所以是4次。
		
三、在tcp连接握手时为何ACK是和SYN一起发送，这里ACK却没有和FIN一起发送呢。     

原因是因为tcp是全双工模式，接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。     
		
四、TCP和UDP有什么区别？    

* TCP是传输控制协议，提供的是面向连接、可靠的字节流服务。通信双方彼此交换数据前，必须先通过三次握手协议建立连接，
之后才能传输数据。TCP提供超时重传，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
* UDP是用户数据报协议，是一个简单的面向无连接的协议。UDP不提供可靠的服务。在数据数据前不用建立连接故而传输速度很快。
UDP主要用于流媒体传输，IP电话等对数据可靠性要求不是很高的场合。    
		
五、交换机与路由器有什么区别？    

* 工作所处的OSI层次不一样，交换机工作在OSI第二层数据链路层，路由器工作在OSI第三层网络层
* 寻址方式不同：交换机根据MAC地址寻址，路由器根据IP地址寻址
* 转发速不同：交换机的转发速度快，路由器转发速度相对较慢。   
      
六、TCP/IP的流量控制？    

利用**滑动窗口实现流量控制**，如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。
所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。     
TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。
若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。  
	 
七、TCP拥塞控制？    
   
防止过多的数据注入到网络中，这样可以**使网络中的路由器或链路不致过载**。拥塞控制所要做的都有一个前提：
**网络能够承受现有的网络负荷**。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。     
拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，
以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。
几种拥塞控制方法：     
慢开始(slow-start )、拥塞避免(congestion avoidance )、快重传( fastretransmit )和快恢复( fastrecovery )。
     
八、ARP是地址解析协议，简单语言解释一下工作原理。    

* 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
* 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，
如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。
* 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，
如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，
然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
* 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。
如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。     
广播发送ARP请求，单播发送ARP响应。     
		
九、ICMP协议？    

ICMP是InternetControl Message Protocol，因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、
路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由器是否可用等网络本身的消息。
这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP报文有两种：差错报告报文和询问报文。

十、DHCP协议？    

动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。通常被应用在大型的局域网络环境中，
主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址、Gateway地址、DNS服务器地址等信息，
并能够提升地址的使用率。    
		
十一、网桥的作用？    

网桥是一个局域网与另一个局域网之间建立连接的桥梁     
		
十二、数据链路层协议可能提供的服务？     

成帧、链路访问、透明传输、可靠交付、流量控制、差错检测、差错纠正、半双工和全双工。
最重要的是**帧定界（成帧）、透明传输以及差错检测**。
		
十三、网络接口卡（网卡）的功能？   

* 进行串行/并行转换。
* 对数据进行缓存。
* 在计算机的操作系统安装设备驱动程序。
* 实现以太网协议。
		
十四、私有（保留）地址？

* A类：10.0.0.0——10.255.255.255
* B类：172.16.0.0——172.31.255.255
* C类：192.168.0.0——192.168.255.255
		
十五、TTL是什么？作用是什么？哪些工具会用到它（ping traceroute ifconfig  netstat）？     

TTL是指生存时间，简单来说，它表示了数据包在网络中的时间，经过一个路由器后TTL就减一，这样TTL最终会减为0，
当TTL为0时，则将数据包丢弃，这样也就是因为两个路由器之间可能形成环，如果没有TTL的限制，则数据包将会在这个环上一直死转，
由于有了TTL，最终TTL为0后，则将数据包丢弃。
      
* ping发送数据包里面有TTL，但是并非是必须的，即是没有TTL也是能正常工作的
* traceroute正是因为有了TTL才能正常工作
* ifconfig是用来配置网卡信息的，不需要TTL
* netstat是用来显示路由表的，也是不需要TTL的
		
十六、路由表是做什么用的？在Linux环境中怎么配置一条默认路由？    

路由表是用来决定如何将一个数据包从一个子网传送到另一个子网的，换句话说就是用来决定从一个网卡接收到的包应该送到哪一个网卡上去。
路由表的每一行至少有**目标网络号、子网掩码、到这个子网应该使用的网卡**这三条信息。     
在Linux上可以用**route add default gw<默认路由器 IP>**命令配置一条默认路由。     
		
十七、RARP？    

逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。
		
十八、运输层协议与网络层协议的区别？    

* 网络层协议负责的是提供主机间的逻辑通信
* 运输层协议负责的是提供进程间的逻辑通信
		
十九、说静态路由和动态路由有什么区别。    

* 静态路由是由管理员手工配置的，适合比较简单的网络或需要做路由特殊控制。
* 而动态路由则是由动态路由协议自动维护的，不需人工干预，适合比较复杂大型的网络。
路由器能够自动地建立自己的路由表，并且能够根据实际实际情况的变化适时地进行调整。
动态路由机制的运作依赖路由器的两个基本功能：**对路由表的维护；路由器之间适时的路由信息交换**。   

二十、HTTP的长连接和短连接?    

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议.
* 短连接:浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
* 长连接:当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，
会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。
实现长连接要客户端和服务端都支持长连接。
* TCP短连接: client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，
然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作.
短连接一般只会在 client/server间传递一次读写操作
* TCP长连接: client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，
它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。  
     
二十一、IO中同步与异步，阻塞与非阻塞区别       

同步和异步关注的是消息通信机制 (synchronous communication/asynchronous communication)     

* 所谓同步，就是在发出一个**调用**时，在没有得到结果之前，该**调用**就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由**调用者**主动等待这个**调用**的结果。
* 而异步则是相反，**调用**在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，
调用者不会立刻得到结果。而是在**调用**发出后，**被调用者**通过状态、通知来通知调用者，或通过回调函数处理这个调用。

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.     

* 阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。
* 非阻塞：不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

二十二、ip地址分段   

* A类网络的IP地址范围为：1.0.0.1－127.255.255.254；
* B类网络的IP地址范围为：128.1.0.1－191.255.255.254；
* C类网络的IP地址范围为：192.0.1.1－223.255.255.254。
		
二十三、为什么TIME_WAIT状态还需要等2*MSL（Max SegmentLifetime，最大分段生存期）秒之后才能返回到CLOSED状态呢？   

如果网络是不可靠的，你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，
而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来**重发可能丢失的ACK报文**。    
		
二十四、关闭TCP连接一定需要4次挥手吗？    

不一定。可以通过设置SOCKET变量的SO_LINGER标志来避免SOCKET在close()之后进入TIME_WAIT状态，
这时将通过发送RST强制终止TCP连接。    
		
二十五、TCP/IP接收发送缓冲区相关概念    

TCP收发需要缓冲区，UDP不需要缓冲区    
  
* 每个TCP套接口有一个发送缓冲区，可以用SO_SNDBUF套接口选项来改变这一缓冲区的大小。当应用进程调用write往套接口写数据时，
内核从应用进程缓冲区中拷贝所有数据到套接口的发送缓冲区，如果套接口发送缓冲区容不下应用程序的所有数据，
或者是应用进程的缓冲区大于套接口的发送缓冲区，或者是套接口的发送缓冲区中有别的数据，应用进程将被挂起。
内核将不从write返回。直到应用进程缓冲区中的所有数据都拷贝到套接口发送缓冲区。
TCP发给对方的数据，对方在收到数据时必须给予确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。
**tcp协议要求对端在收到tcp数据报后，要对其序号进行ACK，只有当收到一个tcp数据报的ACK之后，
才可以把这个tcp数据报(以一个struct sk_buff的形式存在)从socket的发送缓冲队列中清除**。
*   UDP因为是不可靠连接，不必保存应用进程的数据拷贝，应用进程中的数据在沿协议栈向下传递时，以某种形式拷贝到内核缓冲区，
当数据链路层把数据传出后就把内核缓冲区中数据拷贝删除。写UDP套接口的write返回表示应用程序的数据或数据分片已经进入
链路层的输出队列，如果输出队列没有足够的空间存放数据，将返回错误ENOBUFS.  
		
二十六、IO多路复用相关问题？   

概念：IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。     

* 轮询（polling）用一个进程，但是使用非阻塞的I/O读取数据，当一个I/O不可读的时候立刻返回，检查下一个是否可读，
这种方法比较浪费CPU时间，因为大多数时间是不可读，但是仍花费时间不断反复执行read系统调用。
* 异步I/O（asynchronousI/O），当一个描述符准备好的时候用一个信号告诉进程，但是由于信号个数有限，多个描述符时不适用
* I/O多路转接（I/O multiplexing），先构造一张有关描述符的列表（epoll中为队列），然后调用一个函数，
直到这些描述符中的一个准备好时才返回，返回时告诉进程哪些I/O就绪。select和epoll这两个机制都是多路I/O机制的解决方案，
select为POSIX标准中的，而epoll为Linux所特有的。
		
二十七、Select、Epoll机制相关概念(Epoll与Select机制区别)      
   
select的三个缺点：  
  
* 单个进程可监视的fd数量被限制。 
* 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。 
* 对fd进行扫描时是线性扫描。fd剧增后，IO效率较低，因为每次调用都对fd进行线性扫描遍历，
所以随着fd的增加会造成遍历速度慢的性能问题 
* select() 函数的超时参数在返回时也是未定义的，考虑到可移植性，每次在超时之后在下一次进入到select之前都需要重新设置超时参数。  

epoll优点：    

* 支持一个进程打开大数目的socket描述符(FD)
* IO效率不随FD数目增加而线性下降
* 使用mmap加速内核与用户空间的消息传递
* 支持电平触发和边沿触发两种方式     
		
二十八、大端模式与小端模式？    

字节序分为两类：Big-Endian和Little-Endian，引用标准的Big-Endian和Little-Endian的定义如下：       
a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。       
b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。      
c) 网络字节序：TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。   
写个小端模式转大端模式函数：   
判断大端还是小端，大端返回1，小端返回0。  
```
int checkCPU(void)  
{  
union  
{  
        int a;  
        char b;  
}c;  
c.a = 1;  
return (c.b == 1);  
}
```
联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性就可以轻松地获得了CPU对内存采用Little-endian
还是Big-endian模式读写。
		
二十九、Linux下du，df的区别？  

df和du的统计机制不一样。     
* du会把指定目录下所有文件、目录、目录下的文件都统计。是建立在文件系统能看到的的确确是有这样一些文件的基础上的。
也就是说我们能在文件系统里面看到的文件才会被du统计。
* linux中df命令的功能是用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，
目前还剩下多少空间等信息。
		
三十、TCP中MTU和MSS？

* MTU：最大传输单元，通俗的理解就是在网络上传送的最大数据包，单位是字节。以太网对数据帧的长度都有一个限制，
其最大值为1500，这个特性被称作MTU 
* MSS：MSS是Maxitum Segment Size最大分段大小的缩写，意为TCP数据包每次能够传输的最大数据分段，是TCP协议里面的一个概念。   
**一般情况下，MSS=MTU-IP数据包头-TCP数据包头**
		
三十一、mmap和malloc的比较？    

* mmap是系统调用，也是实现虚拟内存到内存的映射，可以让进程的虚拟地址区间切分出一块指定大小的虚拟地址空间vma_struct，
一个进程的所有动态库文件.so的加载，都需要通过mmap系统调用映射指定大小的虚拟地址区间，被mmap映射返回的虚拟地址，
逻辑上被消耗了，直到用户进程调用unmap，会回收回来。malloc向系统获取比较大的内存时，
会通过mmap直接映射一块虚拟地址区间。
**不过这种方式没办法增加文件的长度, 因为要映射的长度在调用mmap()的时候就决定了.**     
* malloc：C语言标准库中的函数，主要用于申请动态内存的分配，其原理是当堆内存不够时，
通过brk/mmap等系统调用向内核申请进程的虚拟地址区间，如果堆内部的内存能满足malloc调用，则直接从堆里获取地址块返回。  
		
三十二、TCP/IP四层参考模型   

* 第一层:网络接口层      
包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。
相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。
* 第二层:网间层    
对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，
负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。
* 第三层:传输层     
对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的
数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。
* 第四层:应用层    
对应于OSI七层参考模型的应用层和表达层。应用程序间沟通的层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、
Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等.    
		
三十三、 ATM    

ATM是异步传输模式的缩略语，ATM采用面向连接的交换方式，它以信元为单位。之所以称其为异步，
是因为来自某一用户的、含有信息的信息元重复出现不是周期性的。
ATM信元总长度53字节，前5字节为信元头负责差错控制、流量控制、路由，后48字节为有用信息。
		
三十四、子网划分、求主机数    

子网划分是通过借用IP地址的若干位主机位来充当子网地址从而将原网络划分为若干子网而实现的。   
**主机数：子网掩码中主机号的位数n，主机数=2的n次方-2；**    
		
三十五、UDP socket一个绑定端口号和不绑定的区别，不绑定是什么后果。不绑定IP又是什么后果？   


端口：bind函数指明了本地地址/端口；connect函数指明了目的地址/端口     

TCP客户端：
* 当TCP客户未绑定IP地址，当它调用connect时内核会根据外出接口给它绑定一个IP地址和一个临时端口号。
并且TCP服务器在接到这个连接后会以这个IP地址作为回应数据报的目的IP地址。
* 当TCP客户绑定了IP地址，它就为发出的数据连接指定了一个源IP地址，并且TCP服务器在接到这个连接后会以
这个IP地址作为回应数据报的目的IP地址。
* TCP客户只能根据四元组（原端口号，原IP地址，目的端口号，目的IP地址）接受数据报。  
   
UDP客户端：    
* 当UDP客户未绑定IP地址，当它调用sendto时内核会根据外出接口给它绑定一个IP地址和一个临时端口号。
（UDP客户可以接收到达它绑定的临时端口的任何UDP数据报）。
* 当UDP客户绑定了IP地址，它就为发出的数据报指定了一个源IP地址，并且UDP服务器在接到这个数据报后会以这个IP地址
作为回应数据报的目的IP地址。（UDP客户只能接收到达它绑定的临时端口并且目的地址为它绑定的IP地址的UDP数据报）。
* UDP客户只能接收目的IP地址为它绑定的IP地址和端口号并且源IP地址为它指定对方的IP地址和端口号的数据报    
	
服务器端:   
TCP服务器：    
* 当TCP服务器绑定通配IP地址，套接口会接收到达它绑定端口的任何TCP连接。
并以接收的目的IP地址作为它的源IP地址（用以确定四源组），以接收的源IP地址作为它的目的IP地址发回应答。
* 当TCP服务器绑定本地IP地址，这就限制了套接口只接收到达它绑定端口并且目的地址为此IP地址的客户连接。
以绑定的目的IP地址作为源IP地址（当然，绑定的IP地址肯定与接收连接的目的IP地址相同，否则它不会接收），
并以接收的源IP地址作为它的目的IP地址发回应答。    
     
UDP服务器：     
* 当UDP服务器绑定通配IP地址，套接口会接收到达它绑定端口的任何UDP数据报。
并以数据报的外出接口的主IP地址为源IP地址，以接收到的源IP地址作为它的目的IP地址发回应答。
* 当UDP服务器绑定本机IP地址，这就限制了套接口只接收到达它绑定端口并且目的地址为此IP地址的UDP数据报。
并以绑定的IP地址作为源IP地址，以接收的源IP地址作为它的目的IP地址发回应答。
* 当UDP服务器调用connect，内核记录下对方的IP地址和端口号，它们包含在传递给connect的套接口地址结构中，
并为UDP服务器绑定了一个临时端口号和IP地址。
（UDP服务器只能接收目的IP地址为它绑定的IP地址和端口号并且源IP地址为它指定对方的IP地址和端口号的数据报）。      

		
三十六、将文件或目录拷贝到另一个Linux系统下？（scp）   

scp就是security copy，用于将文件或者目录从一个Linux系统拷贝到另一个Linux系统下。scp传输数据用的是SSH协议
，保证了数据传输的安全，其格式如下：     
```
scp 远程用户名@IP地址：文件的绝对路径本地Linux系统路径。    
scp 本地Linux系统文件   路径远程用户名@IP地址：远程系统文件绝对路径名。
```
例：   
目前我们处在IP为“192.168.60.133”的Linux系统下，计划将系统下的/home/ixdba/etc.tar.gz文件拷贝到IP
为“192.168.60.168”的远程Linux系统中root用户下的/tmp目录下： 
```
scp  /home/ixdba/etc.tar.gz  root@192.168.60.168:/tmp
```
		
三十七、SIGTERM和SIGKILL有什么不同？   

程序结束(terminate)信号,与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，
shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。
		

3. 查看内存/cpu命令
4. 进程间通信方式
