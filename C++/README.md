####const与#define区别
* **const定义的常量有类型，而#define定义的没有类型**，编译可以对前者进行类型安全检查，而后者仅仅只是做简单替换
* const定义的常量在**编译/运行时确定初值**，而#define定义的常量是**在预编译时进行替换，不分配内存**
* **作用域不同**，const定义的常变量的作用域为该变量的作用域范围。而#define定义的常量作用域为它的定义点到程序结束，
当然也可以在某个地方用#undef取消

####函数重载
相同的作用域，如果两个函数名称相同，而参数不同，称为重载overload（函数的多态性（静态））    
* 合法的重载例子：
``` 
int  abs(int i); 
long abs(long l);
double abs(double d);
```
* 非法的重载例子：
```
int  abs(int i);
long abs(int i); 
void abs(int i);
```
默认值的定义必须遵守从右到左的顺序，**如果某个形参没有默认值，则它左边的参数就不能有默认值**

####引用
引用是给一个变量起别名，**应用没有独立空间，要与它所引用的变量共享空间；要初始化； 一经初始化，不能重新指向其他变量**      
格式：
```
类型 &引用名 = 变量名
```
const引用：指向const对象的引用    
**引用与指针区别**
* 引用访问一个变量是直接访问，而指针是间接访问。
* 引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间。
* 引用一经初始化不能再引用其它变量，而指针可以。

####内联函数
inline关键字告诉编译器，这个函数的调用要尽可能快，可以当普通的函数调用实现，也可以用宏展开的办法实现
```
inline int max(int a, int b)
{
return a > b ? a : b;
}

#define MAX(a, b)  ((a) > (b) ? (a) : (b))
```
* 内联函数调用时，要求实参和形参的类型一致,另外内联函数会先对实参表达式进行求值，然后传递给形参
* 宏调用时只用实参简单地替换形参

####const_cast,static_cast,reinterpret_cast
* const_cast<T>(expr)    
用来移除对象的常量性(cast away the constness);const_cast一般用于指针或者引用;
使用const_cast去除const限定的目的不是为了修改它的内容,使用const_cast去除const限定，通常是为了函数能够接受这个实际参数    
* static_cast<T>(expr)
编译器隐式执行的任何类型转换都可以由static_cast完成,**无法将const转化为nonconst，这个只有const_cast才可以办得到**   
* reinterpret_cast<T>(expr)    
将数据以二进制存在形式的重新解释       
* dynamic_cast<T>(expr)
执行“安全向下”转型操作，也就是说支持运行时识别指针或所指向的对象，这是唯一个无法用旧式语来进行的转型操作


####构造函数与析构函数
#####构造函数

* 构造函数是被自动调用的，且构造函数可以被重载调用；
* 栈上的对象生存期到了会自动调用析构函数；
* 而new operator 做了两件事，一个是创建了对象内存，一个是调用构造函数；
堆上的内存需要delete 释放，做了两件事，一是调用析构函数，二是释放内存。
explicit：编译器不会把声明为explicit的构造函数用于隐式转换，它只能在程序代码中显式创建对象

#####构造函数初始化列表
* 一是构造对象之前，必须先构造对象的成员；
* 二是对象成员构造的顺序与定义时的顺序有关，跟初始化列表顺序无关；
* 三是构造的顺序和析构的顺序相反；
* 四是如果对象成员对应的类没有默认构造函数，那对象成员也只能在初始化列表进行初始化
**如果类是继承而来，基类没有默认构造函数的时候，基类的构造函数要在派生类构造函数初始化列表中调用**

#####拷贝构造函数
使用一个已经存在的对象来初始化一个新的同一类型的对象   
声明：只有一个参数并且参数为该类对象的引用    
**传值会调用拷贝构造函数；引用不调用拷贝构造函数**

#####深拷贝和浅拷贝
* 如果在拷贝的时候顺带连指针指向的内存也分配了，就称为深拷贝
* 如果只是分配指针本身的内存，那就是浅拷贝    
浅拷贝造成的问题是有两个指针指向同块内存，delete 其中一个指针，那么剩下的指针将成为野指针

#####析构函数
不能被重载

####对象的使用
#####四种对象
生存期和作用域：
* 栈对象：隐含调用构造函数（程序中没有显式调用）
* 堆对象：隐含调用构造函数（程序中没有显式调用），要显式释放
* 全局对象、静态全局对象：全局对象的构造先于main函数；已初始化的全局变量或静态全局对象存储于.data段中；
未初始化的全局变量或静态全局对象存储于.bss段中
* 静态局部对象：已初始化的静态局部变量存储于.data段中，未初始化的静态局部变量存储于.bss段中

全局对象的构造先于main函数

#####const
const成员函数：const成员函数不会修改对象的状态；const成员函数只能访问数据成员的值，而不能修改它    
const对象：不能调用非const成员函数
```
const 类名 对象名（参数表）
``` 
**用mutable修饰的数据成员即使在const对象或在const成员函数中都可以被修改。**
```
const int* p ;  // const出现在*左边，表示*p是常量
int * const p2;  // const出现在*右边，表示p2是常量
const int* cosnt p3 = &n3;  // *p3是常量，p3也是常量
```
在类中，如果有const成员，const成员的初始化只能在构造函数初始化列表中进行    
const修饰成员函数，表示该成员函数不能修改对象状态，也就是说它只能访问数据成员，但是不能修改数据成员

####友元
友元函数在类作用域外定义，但它需要在类体中进行说明（作用在于提高程序的运行效率）
```
friend 类型 友元函数名（参数表）
```
* 友元函数不是类的成员函数，在函数体中访问对象的成员，必须用对象名加运算符“.”加对象成员名。
但友元函数可以访问类中的所有成员（公有的、私有的、保护的），一般函数只能访问类中的公有成员。   
例如：
```
double Distance(const Point &p1, const Point &p2)
{
    double dx = p1.x_ - p2.x_;
    double dy = p1.y_ - p2.y_;

    return sqrt(dx * dx + dy * dy);
}
```
* 友元函数不受类中的访问权限关键字限制，可以把它放在类的公有、私有、保护部分，但结果一样。
* 某类的友元函数的作用域并非该类作用域。如果该友元函数是另一类的成员函数，则其作用域为另一类的作用域，
否则与一般函数相同。
* 友元函数破坏了面向对象程序设计类的封装性，所以友元函数如不是必须使用，则尽可能少用。或者用其他手段保证封装性。  
友元类：友元类的所有成员函数都是另一个类的友元函数
```
friend class 类名
```
注意：
* 友元关系是单向的
* 友元关系不能被传递
* 友元关系不能被继承

####运算符重载与成员函数重载
#####成员函数重载
成员函数原型的格式：
```
函数类型 operator 运算符(参数表);
```
成员函数定义的格式：
```
函数类型 类名::operator 运算符(参数表)
{
	函数体;
}
```
#####非成员函数重载
友元函数原型的格式：
```
friend 函数类型 operator 运算符(参数表);
```
友元函数定义的格式：
```
函数类型 类名::operator 运算符(参数表)
{
	函数体;
}
```

####overload,override,overwrite
成员函数被重载(overload)的特征：
* 相同的范围（在同一个类中）；
* 函数名字相同；
* 参数不同；
* virtual关键字可有可无。

覆盖(override)是指派生类函数覆盖基类函数，特征是：
* 不同的范围（分别位于派生类与基类）；
* 函数名字相同；
* 参数相同；
* 基类函数必须有virtual关键字。

隐藏(overwrite)（派生类与基类）
* 不同的范围（分别位于派生类与基类）；
* 函数名与参数都相同，基类无virtual关键字
* 函数名相同，参数不同，virtual可有可无
隐藏发生时（实际上是继承了但不可见），如果在派生类的成员函数中想要调用基类的被隐藏函数，可以使用
“ 基类名::函数名（参数）”的语法形式，如果被隐藏的函数是public的，
则在类体外也可以使用“ 派生类对象.基类名::函数名（参数）” 的语法，也可用“ 派生类指针->基类名::函数名（参数）”的语法

####继承与构造函数
* 基类的构造函数不被继承，派生类中需要声明自己的构造函数
* 声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化调用基类构造函数完成
* 派生类的构造函数需要给基类的构造函数传递参数
调用基类对象成员的构造函数，接着是基类的构造函数，然后是派生类的对象成员的构造函数，最后是派生类自身的构造函数。

####派生类到基类的转换
当派生类以public方式继承基类时,编译器可自动执行的转换(向上转型 upcasting 安全转换)   
* 派生类对象指针自动转化为基类对象指针
* 派生类对象引用自动转化为基类对象引用
* 派生类对象自动转换为基类对象(特有的成员消失)
当派生类以private/protected方式继承基类时
* 派生类对象指针(引用)转化为基类对象指针(引用)需用强制类型转化。但不能用static_cast，要用reinterpret_cast
* 不能把派生类对象强制转换为基类对象

####虚基类
引入：用于有公共基类的场合（解决二义性）
声明：
```
以virtual修饰说明基类，例：class B1:virtual public BB
```
为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝    
* 虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。
* 在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。
如果未列出，则表示调用该虚基类的默认构造函数。
* 在建立对象时，只有最远派生类的构造函数调用虚基类的构造函数，该派生类的其他基类对虚基类构造函数的调用被忽略。

####多态
指发出同样的消息被不同类型的对象接收时有可能导致完全不同的行为。   
实现方式：函数重载/运算符重载/模板/虚函数    
静态绑定：绑定过程出现在编译阶段，在编译期就已确定要调用的函数。   
动态绑定：绑定过程工作在程序运行时执行，在程序运行时才确定将要调用的函数。 

优点：   
* 有助于更好地对程序进行抽象：控制模块能专注于一般性问题的处理；具体的操作交给具体的对象去做
* 有助于提高程序的可扩展性：可以把控制模块与被操作的对象分开；可以添加已定义类的新对象，并能管理该对象；
可以添加新类（已有类的派生类）的新对象，并能管理该对象


####虚函数 
虚函数：
```
virtual 函数类型 函数名称（参数列表）
```
**个函数在基类中被声明为虚函数，则他在所有派生类中都是虚函数**    
**虚函数不能声明为静态**    
**只有通过基类指针或引用调用虚函数才能引发动态绑定**

####虚函数表指针
虚函数的动态绑定是通过虚函数表来实现的。（虚函数表存放虚函数的函数指针）   
包含虚函数的类对象头4个字节存放指向虚函数表的指针

####纯虚函数
定义纯虚函数：不需要实现
```
class 类名{
        virtual 返回值类型 函数名(参数表) = 0；
};
```

####抽象类
作用：抽象类为抽象和设计的目的而声明，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为；  
对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。   
注意：**抽象类只能作为基类来使用**     
**不能声明抽象类的对象**    
**构造函数不能是虚函数，析构函数可以是虚函数**

####虚析构函数
析构函数可以声明为虚函数：  
delete 基类指针：**程序会根据基类指针指向的对象的类型确定要调用的析构函数；
基类的析构函数为虚函数，所有派生类的析构函数都是虚函数**
如果要操作具有继承关系的类的动态对象，最好使用虚析构函数

####RTTI（运行时类型识别）
通过RTTI，能够通过基类的指针或引用来检索其所指对象的实际类型
* typeid:返回指针或引用所指对象的实际类型  type_info  
能够获得一个表达式的类型：typeid(e)    
操作数不是类类型或者是没有虚函数的类，则获取其静态类型；如果操作数是定义了虚函数的类类型，则计算运行时类型。   
常见的用途是**比较两个表达式的类型，或者将表达式的类型与特定类型相比较**
* dynamic_cast:将基类类型的指针或引用安全的转换为派生类型的指针或引用    
转换指针类型失败，返回0；转换引用类型失败，抛出bad_cast类型的异常。    
基类引用转换为派生类引用：
```
dynamic_cast<Type&>(val)
```
**对于带虚函数的类，在运行时执行RTTI操作符，返回动态类型信息；对于其他类型，在编译时执行RTTI，返回静态类型信息。**

####类与类之间的关系
继承/关联/聚合/组合/依赖
* 继承(A is B)
* 关联、聚合、组合(A has B)
* 依赖(A use B)