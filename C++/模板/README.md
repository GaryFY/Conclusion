###流
ostream流的操作
* operator <<
* put()输出单个字符
* write(buf,len)
istream流的操作
* operator >>
* get():读取单个字符，返回一个整数；get(char&)操作，返回一个istream对象的引用
* getline():读取一行 以'\0'结尾
* read(buf,len)
* peek：查看而不读取;putback：将一个字符添加到流

###模板STL
####类模板
```
template  <类型形参表>
class  <类名>
{     //类说明体  }；
template  <类型形参表>
<返回类型> <类名> <类型名表>::<成员函数1>（形参表）
{     //成员函数定义体  }
template  <类型形参表>
<返回类型> <类名> <类型名表>::<成员函数2>（形参表）
{     //成员函数定义体  }
…
template  <类型形参表>
<返回类型> <类名> <类型名表>::<成员函数n>（形参表）
{     //成员函数定义体  }
```
####容器
序列式容器：vector、deque、list      
* 需要频繁在序列中间位置上进行插入和/或删除操作且不需要过多地在序列内部进行长距离跳转，应该选择list
* vector头部与中间插入删除效率较低，在尾部插入与删除效率高
* deque是在头部与尾部插入与删除效率较高

关联式容器：set、multiset、map、multimap     
* 相同点： set，同map一样，所有元素都会根据元素的键值自动被排序，因为set/map两者的所有各种操作，都只是转而调用RB-tree的操作行为，
不过，值得注意的是，两者都不允许两个元素有相同的键值。     
* 不同点：set的元素不像map那样可以同时拥有实值(value)和键值(key)，set元素同时拥有实值和键值，且实值就是键值，键值就是实值，
而map的所有元素都是pair，同时拥有实值(value)和键值(key)，pair的第一个元素被视为键值，第二个元素被视为实值。
* multiset/multimap，他们的特性及用法和set/map完全相同，唯一的差别就在于它们允许键值重复，
即所有的插入操作基于RB-tree的insert_equal()而非insert_unique()

####迭代器
代器的主要好处是，为所有容器提供了一组很小的公共接口。迭代器以++进行累进，以*进行提领，因而它类似于指针，
我们可以把它视为一种smart pointer

####适配器
* 容器适配器：用来扩展7种基本容器，它们和顺序容器相结合构成栈、队列和优先队列容器
* 迭代器适配器（反向迭代器、插入迭代器、IO流迭代器）
* 函数适配器（函数对象适配器、成员函数适配器、普通函数适配器）

**获取insert或者erase返回的迭代器，以便用重新获取新的有效的迭代器进行正确的操作**